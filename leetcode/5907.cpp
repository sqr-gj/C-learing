/* 下一个更大的数值平衡数
如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。
给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。

示例 1：
输入：n = 1
输出：22
解释：
22 是一个数值平衡数，因为：
- 数字 2 出现 2 次
这也是严格大于 1 的最小数值平衡数。

示例 2：
输入：n = 1000
输出：1333
解释：
1333 是一个数值平衡数，因为：
- 数字 1 出现 1 次。
- 数字 3 出现 3 次。
这也是严格大于 1000 的最小数值平衡数。
注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。

示例 3：
输入：n = 3000
输出：3133
解释：
3133 是一个数值平衡数，因为：
- 数字 1 出现 1 次。
- 数字 3 出现 3 次。
这也是严格大于 3000 的最小数值平衡数。
*/

#include <unordered_map>
#include <vector>
#include <algorithm>

using namespace std;

//判断是否为数值平衡数
bool is_balance (int i) {
    string s = to_string(i);
    unordered_map<char, int> s_num;
    int sz = s.size();
    string temp;
    int num;
    for (int j = 0; j < sz; ++j) {
        ++s_num[s[j]];
        temp = s[j];
        num = stoi(temp);
        if (s_num[s[j]] > num)
            return false;
    }
    for (auto n : s_num) {
        temp = n.first;
        num = stoi(temp);
        if (n.second != num)
            return false;
    }
    return true;
}

//264周赛                     2021/10/24
int nextBeautifulNumber(int n) {
//    //从n递增判断-> 超时
//    while (!is_balance(++n)) {

//    }
//    return n;

    //预先列举出所有数值平衡数
    vector<int> balance_num = {1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444, 14444, 22333, 23233, 23323, 23332
                , 32233, 32323, 32332, 33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
                               122333, 123233,123323, 123332,132233, 132323, 132332, 133223, 133232, 133322, 155555, 515555, 551555,                                        555155, 555515, 555551, 224444, 242444, 244244, 244424, 244442, 422444, 424244, 424424, 424442, 442244,                                      442424, 442442, 444224, 444242, 444422, 212333, 213233, 213332, 213323, 221333, 223133, 223313, 223331,                              231233, 231323, 231332, 232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 312233,                                       312323,312332, 313223, 313232, 313322, 321233, 321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213,                               323231, 323312, 323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321, 333122, 333212,
                               333221, 666666, 1224444};
    sort(balance_num.begin(), balance_num.end());
    int sz = balance_num.size();
    for (int i = 0; i < sz; ++i) {
        if (n < balance_num[i])
            return balance_num[i];
    }
    return n;
}
